/* ==================== */
/* == Radar Charts
/* ==================== */

.charts-radar {
  --size: calc( #{$width / 4} / var(--scale) );
  background-image:
    repeating-radial-gradient(
      circle at 50%,
      rgba(0, 0, 0, .2),
      rgba(0, 0, 0, .2) 2px,
      transparent 2px,
      transparent calc(var(--size) * var(--step))
    ),
    repeating-radial-gradient(
      circle at 50%,
      rgba(0, 0, 0, .1),
      rgba(0, 0, 0, .1) 2px,
      transparent 2px,
      transparent var(--size)
    );
  border: 2px solid;
  border-radius: 50%;
  height: $width / 2;
  margin: 0 auto;
  position: relative;
  width: $width / 2;

  /*&::before {
    content: "";
    background: red;
    position: absolute;
    width: 100%;
    height: 100%;
    clip-path:
      // hard-coded values: what's the math behind?
      polygon(
        50% 50%,
        22.4% 50.35%,
        29.84% 75.71%,
        59.13% 89.84%,
        72.87% 61.26%,
        77.56% 36.22%,
        54.33% 29.72%
      );
  }*/

  /**
   * Placing items around a circle
   * @author Ana Tudor
   * @link https://stackoverflow.com/questions/12813573/position-icons-into-circle
   * @link http://dabblet.com/gist/3866686
   *
   * @note Negative values for radius helps to start at the top left corner
   */
  /*dt {
    --angle: calc(1turn / var(--items));
    --radius: calc( #{$width / -4} - 50% );
    --index: 1;
    left: 50%;
    margin: 0;
    position: absolute;
    top: 50%;
    transform:
      translate3d(-50%, -50%, 0)
      rotate( calc(var(--angle) * var(--index) * -1) )
      translate( var(--radius) )
      rotate( calc(var(--angle) * var(--index)) );

      // @note Using `$number - 2` allow to rotate terms clockwise, to start from top left corner
      @each $number in 1, 2, 3, 4, 5, 6, 7 {
        &:nth-of-type(#{$number}) {
          --index: #{$number - 2};
        }
      }
  }*/

/**
 * @author Sara Soueidan
 * @link https://tympanus.net/codrops/2013/08/09/building-a-circular-navigation-with-css-transforms/
 *
 * @note Because we skew items, clip-path() needs to take skew angle into account
 * @note To do so, we need to know skewed width (which is hypothenuse of the resulting triangle)
 * @note We only know two angles (skew one + suqare one) and a side (initial width),
 * @note So we need to compute the sinus of the opposite angle to get hypothenuse
 * @note Thanks god, Stereokai made trigonometry functions in pure CSS:
 *
 * @author Stereokai
 * @link https://gist.github.com/stereokai/7666bfe93929b14c2dced148c79e0e97
 */
  dd {
    --part: calc( 360deg / var(--items) );
    --skew: calc( 90deg - var(--part) );
    --opposite: calc( 180 - (90 + (90 - (360 / var(--items)))) );
    // get opposite angle in radians
    --angle: calc( var(--opposite) * 0.01745329251 );
    // calc() sin, dark wizardry!
    --sin-term1: var(--angle);
    --sin-term2: calc((var(--angle) * var(--angle) * var(--angle)) / 6);
    --sin-term3: calc((var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle)) / 120);
    --sin-term4: calc((var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle)) / 5040);
    --sin-term5: calc((var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle) * var(--angle)) / 362880);
    --sin: calc(var(--sin-term1) - var(--sin-term2) + var(--sin-term3) - var(--sin-term4) + var(--sin-term5));
    // calc() hypothenuse
    --hypo: calc( #{$base / 4} / var(--sin) );
    // get the ratio: skewed / initial width
    --ratio: calc( var(--hypo) / #{$base / 4} );
    left: 0;
    margin: 0;
    position: absolute;
    top: 0;
    transform-origin: 100% 100%;
    transform:
      rotate( calc(var(--part) * var(--index, 1)) )
      skew( var(--skew) );
    width: 50%;
    height: 50%;

      background: blue;


    @each $number in 1, 2, 3, 4, 5, 6, 7 {
      &:nth-of-type(#{$number}) {
        --index: #{$number};
        --pos: calc( 100% - (var(--#{$number + 1}) * 100% / (var(--scale) * var(--ratio) ) ) );
        clip-path: polygon(
          100% var(--pos),
          calc( 100% - ( var(--#{$number}) * 100% / var(--scale) ) ) 100%,
          100% 100%
        );
      }
    }
  }

  + figcaption {
    text-align: center;
  }
}
